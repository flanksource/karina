package types

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"

	"github.com/flanksource/karina/pkg/api/calico"
	konfigadm "github.com/flanksource/konfigadm/pkg/types"
	"github.com/jinzhu/copier"
	yaml "gopkg.in/flanksource/yaml.v3"
)

type Enabled struct {
	// +optional
	Disabled bool `yaml:"disabled" json:"disabled"`
}

type Disabled struct {
	// +optional
	Disabled bool `yaml:"disabled" json:"disabled"`
	// +optional
	Version string `yaml:"version" json:"version"`
}

func (d Disabled) IsDisabled() bool {
	if d.Disabled {
		return true
	}
	return d.Version == ""
}

type CertManager struct {
	Version string `yaml:"version" json:"version"`

	// Details of a vault server to use for signing ingress certificates
	Vault *VaultClient `yaml:"vault,omitempty" json:"vault,omitempty"`
}

type VaultClient struct {
	// The address of a remote Vault server to use for signing
	Address string `yaml:"address" json:"address"`

	// The path to the PKI Role to use for signing ingress certificates e.g. /pki/role/ingress-ca
	Path string `yaml:"path" json:"path"`

	// A VAULT_TOKEN to use when authenticating with Vault
	Token string `yaml:"token" json:"token"`
}

// VM captures the specifications of a virtual machine
// +kubebuilder:object:generate=false
type VM struct {
	Name   string `yaml:"name,omitempty" json:"name,omitempty"`
	Prefix string `yaml:"prefix,omitempty" json:"prefix,omitempty"`
	// Number of VM's to provision
	Count          int      `yaml:"count" json:"count,omitempty"`
	ContentLibrary string   `yaml:"contentLibrary" json:"contentLibrary,omitempty"`
	Template       string   `yaml:"template" json:"template,omitempty"`
	Cluster        string   `yaml:"cluster,omitempty" json:"cluster,omitempty"`
	Folder         string   `yaml:"folder,omitempty" json:"folder,omitempty"`
	Datastore      string   `yaml:"datastore,omitempty" json:"datastore,omitempty"`
	ResourcePool   string   `yaml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	CPUs           int32    `yaml:"cpu" json:"cpu,omitempty"`
	MemoryGB       int64    `yaml:"memory" json:"memory,omitempty"`
	Network        []string `yaml:"networks,omitempty" json:"networks,omitempty"`
	// Size in GB of the VM root volume
	DiskGB int `yaml:"disk" json:"disk"`
	// Tags to be applied to the VM
	Tags     map[string]string `yaml:"tags,omitempty" json:"tags,omitempty"`
	Commands []string          `yaml:"commands,omitempty" json:"commands,omitempty"`
	// A path to a konfigadm specification used for configuring the VM on creation.
	KonfigadmFile      string             `yaml:"konfigadm,omitempty" json:"konfigadm,omitempty"`
	IP                 string             `yaml:"-" json:"-"`
	Konfigadm          *konfigadm.Config  `yaml:"-" json:"-"`
	Annotations        map[string]string  `yaml:"annotations,omitempty" json:"annotations,omitempty"`
	KubeletExtraArgs   map[string]string  `yaml:"kubeletExtraArgs,omitempty" json:"kubeletExtraArgs,omitempty"`
	LoadBalancerConfig LoadBalancerConfig `yaml:"loadBalancerConfig,omitempty" json:"loadBalancerConfig,omitempty"`
}

func (vm VM) GetTags() map[string]string {
	return vm.Tags
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (vm *VM) DeepCopyInto(out *VM) {
	*out = *vm
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VPA.
func (vm *VM) DeepCopy() *VM {
	if vm == nil {
		return nil
	}
	out := new(VM)
	vm.DeepCopyInto(out)
	return out
}

type LoadBalancerConfig struct {
	Ports       []string     `json:"ports" yaml:"ports"`
	MonitorPort *MonitorPort `json:"monitorPort,omitempty" yaml:"monitorPort,omitempty"`
}

type MonitorPort struct {
	Port      string `json:"port" yaml:"port"`
	Timeout   int64  `json:"timeout" yaml:"timeout"`
	Interval  int64  `json:"interval" yaml:"interval"`
	RiseCount int64  `json:"riseCount" yaml:"riseCount"`
	FallCount int64  `json:"fallCount" yaml:"fallCount"`
}

type Calico struct {
	// +optional
	Disabled `yaml:",inline" json:",inline"`
	// +optional
	IPIP calico.IPIPMode `yaml:"ipip" json:"ipip"`
	// +optional
	VxLAN calico.VXLANMode `yaml:"vxlan" json:"vxLAN"`
	// +optional
	Log string `yaml:"log,omitempty" json:"log,omitempty"`
	// +optional
	BGPPeers []calico.BGPPeer `yaml:"bgpPeers,omitempty" json:"bgpPeers,omitempty"`
	// +optional
	BGPConfig calico.BGPConfiguration `yaml:"bgpConfig,omitempty" json:"bgpConfig,omitempty"`
	// +optional
	IPPools []calico.IPPool `yaml:"ipPools,omitempty" json:"ipPools,omitempty"`
}

type Antrea struct {
	// +optional
	Disabled `yaml:",inline" json:",inline"`
	// +optional
	IsCertReady bool `yaml:"isCertReady" json:"isCertReady"`
}

type OPA struct {
	Disabled          bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	KubeMgmtVersion   string `yaml:"kubeMgmtVersion,omitempty" json:"kubeMgmtVersion,omitempty"`
	Version           string `yaml:"version,omitempty" json:"version,omitempty"`
	BundleURL         string `yaml:"bundleUrl,omitempty" json:"bundleUrl,omitempty"`
	BundlePrefix      string `yaml:"bundlePrefix,omitempty" json:"bundlePrefix,omitempty"`
	BundleServiceName string `yaml:"bundleServiceName,omitempty" json:"bundleServiceName,omitempty"`
	LogFormat         string `yaml:"logFormat,omitempty" json:"logFormat,omitempty"`
	SetDecisionLogs   bool   `yaml:"setDecisionLogs,omitempty" json:"setDecisionLogs,omitempty"`
	// Policies is a path to directory containing .rego policy files
	Policies string `yaml:"policies,omitempty" json:"policies,omitempty"`
	// Log level for opa server, one of: `debug`,`info`,`error` (default: `error`)
	LogLevel string `yaml:"logLevel,omitempty" json:"logLevel,omitempty"`
	E2E      OPAE2E `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

type OPAE2E struct {
	Fixtures string `yaml:"fixtures,omitempty" json:"fixtures,omitempty"`
}

type Gatekeeper struct {
	Disabled `yaml:",inline" json:",inline"`
	// Templates is a path to directory containing gatekeeper templates
	Templates string `yaml:"templates,omitempty" json:"templates,omitempty"`
	// Templates is a path to directory containing gatekeeper constraints
	Constraints         string        `yaml:"constraints,omitempty" json:"constraints,omitempty"`
	AuditInterval       int           `yaml:"auditInterval,omitempty" json:"auditInterval,omitempty"`
	WhitelistNamespaces []string      `yaml:"whitelistNamespaces,omitempty" json:"whitelistNamespaces,omitempty"`
	E2E                 GatekeeperE2E `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

type GatekeeperE2E struct {
	Fixtures string `yaml:"fixtures,omitempty" json:"fixtures,omitempty"`
}

type Harbor struct {
	Disabled        bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Version         string `yaml:"version,omitempty" json:"version,omitempty"`
	RegistryPVC     string `yaml:"registryPVC,omitempty" json:"registryPVC,omitempty"`
	ChartPVC        string `yaml:"chartPVC,omitempty" json:"chartPVC,omitempty"`
	ChartVersion    string `yaml:"chartVersion,omitempty" json:"chartVersion,omitempty"`
	AdminPassword   string `yaml:"-" json:"-"`
	ClairVersion    string `yaml:"clairVersion" json:"clairVersion,omitempty"`
	RegistryVersion string `yaml:"registryVersion" json:"registryVersion"`
	// Logging level for various components, valid options are `info`,`warn`,`debug` (default: `warn`)
	LogLevel          string                   `yaml:"logLevel,omitempty" json:"logLevel,omitempty"`
	DB                *DB                      `yaml:"db,omitempty" json:"db,omitempty"`
	URL               string                   `yaml:"url,omitempty" json:"url,omitempty"`
	Projects          map[string]HarborProject `yaml:"projects,omitempty" json:"projects,omitempty"`
	Settings          *HarborSettings          `yaml:"settings,omitempty" json:"settings,omitempty"`
	Replicas          int                      `yaml:"replicas,omitempty" json:"replicas,omitempty"`
	S3                *S3Connection            `yaml:"s3,omitempty" json:"s3,omitempty"`
	S3DisableRedirect bool                     `yaml:"s3DisableRedirect" json:"s3DisableRedirect,omitempty"`
	// S3 bucket for the docker registry to use
	Bucket string `yaml:"bucket" json:"bucket"`
}

type HarborSettings struct {
	AuthMode                     string `json:"auth_mode,omitempty" yaml:"auth_mode,omitempty"`
	EmailFrom                    string `json:"email_from,omitempty" yaml:"email_from,omitempty"`
	EmailHost                    string `json:"email_host,omitempty" yaml:"email_host,omitempty"`
	EmailIdentity                string `json:"email_identity,omitempty" yaml:"email_identity,omitempty"`
	EmailPassword                string `json:"email_password,omitempty" yaml:"email_password,omitempty"`
	EmailInsecure                string `json:"email_insecure,omitempty" yaml:"email_insecure,omitempty"`
	EmailPort                    string `json:"email_port,omitempty" yaml:"email_port,omitempty"`
	EmailSsl                     *bool  `json:"email_ssl,omitempty" yaml:"email_ssl,omitempty"`
	EmailUsername                string `json:"email_username,omitempty" yaml:"email_username,omitempty"`
	LdapURL                      string `json:"ldap_url,omitempty" yaml:"ldap_url,omitempty"`
	LdapBaseDN                   string `json:"ldap_base_dn,omitempty" yaml:"ldap_base_dn,omitempty"`
	LdapFilter                   string `json:"ldap_filter,omitempty" yaml:"ldap_filter,omitempty"`
	LdapScope                    string `json:"ldap_scope,omitempty" yaml:"ldap_scope,omitempty"`
	LdapSearchDN                 string `json:"ldap_search_dn,omitempty" yaml:"ldap_search_dn,omitempty"`
	LdapSearchPassword           string `json:"ldap_search_password,omitempty" yaml:"ldap_search_password,omitempty"`
	LdapTimeout                  string `json:"ldap_timeout,omitempty" yaml:"ldap_timeout,omitempty"`
	LdapUID                      string `json:"ldap_uid,omitempty" yaml:"ldap_uid,omitempty"`
	LdapVerifyCert               *bool  `json:"ldap_verify_cert,omitempty" yaml:"ldap_verify_cert,omitempty"`
	LdapGroupAdminDN             string `json:"ldap_group_admin_dn,omitempty" yaml:"ldap_group_admin_dn,omitempty"`
	LdapGroupAttributeName       string `json:"ldap_group_attribute_name,omitempty" yaml:"ldap_group_attribute_name,omitempty"`
	LdapGroupBaseDN              string `json:"ldap_group_base_dn,omitempty" yaml:"ldap_group_base_dn,omitempty"`
	LdapGroupSearchFilter        string `json:"ldap_group_search_filter,omitempty" yaml:"ldap_group_search_filter,omitempty"`
	LdapGroupSearchScope         string `json:"ldap_group_search_scope,omitempty" yaml:"ldap_group_search_scope,omitempty"`
	LdapGroupMembershipAttribute string `json:"ldap_group_membership_attribute,omitempty" yaml:"ldap_group_membership_attribute,omitempty"`
	ProjectCreationRestriction   string `json:"project_creation_restriction,omitempty" yaml:"project_creation_restriction,omitempty"`
	ReadOnly                     string `json:"read_only,omitempty" yaml:"read_only,omitempty"`
	SelfRegistration             *bool  `json:"self_registration,omitempty" yaml:"self_registration,omitempty"`
	TokenExpiration              int    `json:"token_expiration,omitempty" yaml:"token_expiration,omitempty"`
	OidcName                     string `json:"oidc_name,omitempty" yaml:"oidc_name,omitempty"`
	OidcEndpoint                 string `json:"oidc_endpoint,omitempty" yaml:"oidc_endpoint,omitempty"`
	OidcClientID                 string `json:"oidc_client_id,omitempty" yaml:"oidc_client_id,omitempty"`
	OidcClientSecret             string `json:"oidc_client_secret,omitempty" yaml:"oidc_client_secret,omitempty"`
	OidcScope                    string `json:"oidc_scope,omitempty" yaml:"oidc_scope,omitempty"`
	OidcVerifyCert               string `json:"oidc_verify_cert,omitempty" yaml:"oidc_verify_cert,omitempty"`
	RobotTokenDuration           int    `json:"robot_token_duration,omitempty" yaml:"robot_token_duration,omitempty"`
}

type HarborProject struct {
	Name  string            `yaml:"name,omitempty" json:"name,omitempty"`
	Roles map[string]string `yaml:"roles,omitempty" json:"roles,omitempty"`
}

type DB struct {
	Host     string `yaml:"host" json:"host"`
	Username string `yaml:"username" json:"username"`
	Password string `yaml:"password" json:"password"`
	Port     int    `yaml:"port" json:"port"`
}

func (db DB) GetConnectionURL(name string) string {
	return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable", db.Username, url.QueryEscape(db.Password), db.Host, db.Port, name)
}

type PostgresOperator struct {
	Disabled       `yaml:",inline" json:",inline"`
	DBVersion      string `yaml:"dbVersion,omitempty" json:"dbVersion,omitempty"`
	BackupBucket   string `yaml:"backupBucket,omitempty" json:"backupBucket,omitempty"`
	BackupSchedule string `yaml:"backupSchedule,omitempty" json:"backupSchedule,omitempty"`
	SpiloImage     string `yaml:"spiloImage,omitempty" json:"spiloImage,omitempty"`
	BackupImage    string `yaml:"backupImage,omitempty" json:"backupImage,omitempty"`
}

type SMTP struct {
	Server   string `yaml:"server,omitempty" json:"server,omitempty"`
	Username string `yaml:"username,omitempty" json:"username,omitempty"`
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
	Port     int    `yaml:"port,omitempty" json:"port,omitempty"`
	From     string `yaml:"from,omitempty" json:"from,omitempty"`
}

type S3 struct {
	S3Connection `yaml:",inline" json:",inline"`
	CSIVolumes   bool `yaml:"csiVolumes,omitempty" json:"csiVolumes,omitempty"`
	// Provide a KMS Master Key
	KMSMasterKey string `yaml:"kmsMasterKey,omitempty" json:"kmsMasterKey,omitempty"`
	E2E          S3E2E  `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

type S3Connection struct {
	AccessKey string `yaml:"access_key,omitempty" json:"access_key,omitempty"`
	SecretKey string `yaml:"secret_key,omitempty" json:"secret_key,omitempty"`
	Bucket    string `yaml:"bucket,omitempty" json:"bucket,omitempty"`
	Region    string `yaml:"region,omitempty" json:"region,omitempty"`
	// The endpoint at which the S3-like object storage will be available from inside the cluster
	// e.g. if minio is deployed inside the cluster, specify: `http://minio.minio.svc:9000`
	Endpoint string `yaml:"endpoint,omitempty" json:"endpoint,omitempty"`
	// UsePathStyle http://s3host/bucket instead of http://bucket.s3host
	UsePathStyle bool `yaml:"usePathStyle" json:"usePathStyle,omitempty"`
	// Skip TLS verify when connecting to S3
	SkipTLSVerify bool `yaml:"skipTLSVerify" json:"skipTLSVerify,omitempty"`
}

type Minio struct {
	Disabled     `yaml:",inline" json:",inline"`
	Replicas     int         `yaml:"replicas,omitempty" json:"replicas,omitempty"`
	AccessKey    string      `yaml:"access_key,omitempty" json:"access_key,omitempty"`
	SecretKey    string      `yaml:"secret_key,omitempty" json:"secret_key,omitempty"`
	KMSMasterKey string      `yaml:"kmsMasterKey,omitempty" json:"kmsMasterKey,omitempty"`
	Persistence  Persistence `yaml:"persistence,omitempty" json:"persistence,omitempty"`
}

type S3E2E struct {
	Minio bool `yaml:"minio,omitempty" json:"minio,omitempty"`
}

type NFS struct {
	Host string `yaml:"host,omitempty" json:"host,omitempty"`
	Path string `yaml:"path,omitempty" json:"path,omitempty"`
}

// Configures the Nginx Ingress Controller, the controller Docker image is forked from upstream
// to include more LUA packages for OAuth. <br>
// To configure global settings not available below, override the <b>ingress-nginx/nginx-configuration</b> configmap with
// settings from [here](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/)
type Nginx struct {
	Disabled bool `yaml:"disabled" json:"disabled"`
	// The version of the nginx controller to deploy (default: `0.25.1.flanksource.1`)
	Version string `yaml:"version" json:"version"`

	// Configurations to apply to Nginx, see [configmap](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/) for a full list of options
	Config map[string]string `yaml:"config,omitempty" json:"config,omitempty"`
}

type OAuth2Proxy struct {
	Disabled bool   `yaml:"disabled" json:"disabled"`
	Version  string `yaml:"version,omitempty" json:"version,omitempty"`
}

type Ldap struct {
	Disabled bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Host     string `yaml:"host,omitempty" json:"host,omitempty"`
	Port     string `yaml:"port,omitempty" json:"port,omitempty"`
	Username string `yaml:"username,omitempty" json:"username,omitempty"`
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
	Domain   string `yaml:"domain,omitempty" json:"domain,omitempty"`
	// Members of this group will become cluster-admins
	AdminGroup string `yaml:"adminGroup,omitempty" json:"adminGroup,omitempty"`
	UserDN     string `yaml:"userDN,omitempty" json:"userDN,omitempty"`
	GroupDN    string `yaml:"groupDN,omitempty" json:"groupDN,omitempty"`
	// GroupObjectClass is used for searching user groups in LDAP. Default is `group` for Active Directory and `groupOfNames` for Apache DS
	GroupObjectClass string `yaml:"groupObjectClass,omitempty" json:"groupObjectClass,omitempty"`
	// GroupNameAttr is the attribute used for returning group name in OAuth tokens. Default is `name` in ActiveDirectory and `DN` in Apache DS
	GroupNameAttr string  `yaml:"groupNameAttr,omitempty" json:"groupNameAttr,omitempty"`
	E2E           LdapE2E `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

type LdapE2E struct {
	// Ff true, deploy a mock LDAP server for testing
	Mock bool `yaml:"mock,omitempty" json:"mock,omitempty"`
	// Username to be used for OIDC integration tests
	Username string `yaml:"username,omitempty" json:"username,omitempty"`
	// Password to be used for or OIDC integration tests
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
}

func (ldap Ldap) GetConnectionURL() string {
	return fmt.Sprintf("ldaps://%s:%s", ldap.Host, ldap.Port)
}

type Kubernetes struct {
	Version string `yaml:"version" json:"version"`
	// Configure additional kubelet [flags](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/)
	KubeletExtraArgs map[string]string `yaml:"kubeletExtraArgs,omitempty" json:"kubeletExtraArgs,omitempty"`
	// Configure additional kube-controller-manager [flags](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/)
	ControllerExtraArgs map[string]string `yaml:"controllerExtraArgs,omitempty" json:"controllerExtraArgs,omitempty"`
	// Configure additional kube-scheduler [flags](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/)
	SchedulerExtraArgs map[string]string `yaml:"schedulerExtraArgs,omitempty" json:"schedulerExtraArgs,omitempty"`
	// Configure additional kube-apiserver [flags](https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/)
	APIServerExtraArgs map[string]string `yaml:"apiServerExtraArgs,omitempty" json:"apiServerExtraArgs,omitempty"`
	// Configure additional etcd [flags](https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/configuration.md)
	EtcdExtraArgs map[string]string `yaml:"etcdExtraArgs,omitempty" json:"etcdExtraArgs,omitempty"`
	MasterIP      string            `yaml:"masterIP,omitempty" json:"masterIP,omitempty"`
	// Configure Kubernetes auditing
	AuditConfig AuditConfig `yaml:"auditing,omitempty" json:"auditing,omitempty"`
	// EncryptionConfig is used to specify the encryption configuration file.
	EncryptionConfig EncryptionConfig `yaml:"encryption,omitempty" json:"encryption,omitempty"`
	// Configure container runtime: docker/containerd
	ContainerRuntime string `yaml:"containerRuntime" json:"containerRuntime,omitempty"`
}

type Kind struct {
	PortMappings map[string]int32 `yaml:"portMappings,omitempty" json:"portMappings,omitempty"`
	WorkerCount  int              `yaml:"workerCount,omitempty" json:"workerCount,omitempty"`
}

// UnmarshalYAML is used to customize the YAML unmarshalling of
// Kubernetes objects. It makes sure that if a audit policy is specified
// that a default audit-log-path will be supplied.
func (c *Kubernetes) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type rawKubernetes Kubernetes
	raw := rawKubernetes{}

	if err := unmarshal(&raw); err != nil {
		return err
	}
	if raw.AuditConfig.PolicyFile != "" {
		if raw.APIServerExtraArgs == nil {
			raw.APIServerExtraArgs = make(map[string]string)
		}
		if _, found := raw.APIServerExtraArgs["audit-log-path"]; !found {
			raw.APIServerExtraArgs["audit-log-path"] = "/var/log/audit/cluster-audit.log"
		}
	}

	*c = Kubernetes(raw)
	return nil
}

// Canary-checker allows for the deployment and configuration of the canary-checker
type CanaryChecker struct {
	Enabled `yaml:",inline" json:",inline"`
	// +optional
	Version string `yaml:"version" json:"version,"`
	// +optional
	AggregateServers []string `yaml:"aggregateServers" json:"aggregateServers"`
}

type Dashboard struct {
	Enabled `yaml:",inline" json:",inline"`
	Version string `yaml:"version,omitempty" json:"version,omitempty"`
}

type Dex struct {
	Disabled `yaml:",inline" json:",inline"`
}

type Kpack struct {
	Disabled `yaml:",inline" json:",inline"`
}

type DynamicDNS struct {
	Disabled bool `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	// Set to true if you want DNS records added to k8s-api and "*" for every new
	// worker and master created.
	UpdateHosts bool `yaml:"updateHosts,omitempty" json:"updateHosts,omitempty"`
	// Nameserver and port for dynamic DNS updates
	Nameserver string `yaml:"nameserver,omitempty" json:"nameserver,omitempty"`
	// Dynamic DNS key secret
	Key string `yaml:"key,omitempty" json:"key,omitempty"`
	// Dynamic DNS key name
	KeyName string `yaml:"keyName,omitempty" json:"keyName,omitempty"`
	// A Dynamic DNS signature algorithm, one of: hmac-md5, hmac-sha1, hmac-256, hmac-512
	Algorithm string `yaml:"algorithm,omitempty" json:"algorithm,omitempty"`
	Zone      string `yaml:"zone,omitempty" json:"zone,omitempty"`
	AccessKey string `yaml:"accessKey,omitempty" json:"accessKey,omitempty"`
	SecretKey string `yaml:"secretKey,omitempty" json:"secretKey,omitempty"`
	// Type of DNS provider. Defaults to RFC 2136 Dynamic DNS. If using "route53" you
	// must specify accessKey, secretKey and zone
	Type string `yaml:"type,omitempty" json:"type,omitempty"`
}

func (dns DynamicDNS) IsEnabled() bool {
	return !dns.Disabled
}

type Monitoring struct {
	Disabled           bool          `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	AlertEmail         string        `yaml:"alert_email,omitempty" json:"alert_email,omitempty"`
	Version            string        `yaml:"version,omitempty" json:"version,omitempty"`
	Prometheus         Prometheus    `yaml:"prometheus,omitempty" json:"prometheus,omitempty"`
	Karma              Karma         `yaml:"karma,omitempty" json:"karma,omitempty"`
	Grafana            Grafana       `yaml:"grafana,omitempty" json:"grafana,omitempty"`
	AlertManager       AlertManager  `yaml:"alertmanager,omitempty" json:"alertManager,omitempty"`
	KubeStateMetrics   string        `yaml:"kubeStateMetrics,omitempty" json:"kubeStateMetrics,omitempty"`
	KubeRbacProxy      string        `yaml:"kubeRbacProxy,omitempty" json:"kubeRbacProxy,omitempty"`
	NodeExporter       string        `yaml:"nodeExporter,omitempty" json:"nodeExporter,omitempty"`
	AddonResizer       string        `yaml:"addonResizer,omitempty" json:"addonResizer,omitempty"`
	PrometheusOperator string        `yaml:"prometheus_operator,omitempty" json:"prometheus_operator,omitempty"`
	E2E                MonitoringE2E `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

// ExternalClusters is a map of clusterName: clusterApiEndpoints
// with convenience methods.
type ExternalClusters map[string]string

// AddSelf adds the default internal k8s API endpoint under the given cluster name
// to describe "internal" access.
func (ec *ExternalClusters) AddSelf(name string) {
	if *ec == nil {
		newmap := make(ExternalClusters)
		*ec = newmap
	}
	(*ec)[name] = "https://kubernetes.default"
}

// Configuration for [KubeWebView](https://github.com/hjacobs/kube-web-view) resource viewer
type KubeWebView struct {
	Disabled       bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Version        string `yaml:"version,omitempty" json:"version,omitempty"`
	LogsEnabled    bool   `yaml:"viewLogs,omitempty" json:"viewLogs,omitempty"`
	SecretsEnabled bool   `yaml:"viewSecrets,omitempty" json:"viewSecrets,omitempty"`
	// a map of extra clusters that kube-resource report will report on.
	// in the form:
	// clusterName: cluster API endpoint
	// e.g.:
	//  extraClusters:
	//    k8s-reports2: "https://10.100.2.69:6443"
	// the CA for the current cluster needs to be trusted by
	// the given external cluster.
	ExternalClusters ExternalClusters `yaml:"extraClusters,omitempty" json:"extraClusters,omitempty"`
}

// Configuration for [Karma](https://github.com/prymitive/karma/releases) Alert Dashboard
type Karma struct {
	Version       string            `yaml:"version,omitempty" json:"version,omitempty"`
	AlertManagers map[string]string `yaml:"alertManagers" json:"alertManagers"`
}

// Configuration for [KubeResourceReport](https://github.com/hjacobs/kube-resource-report)
type KubeResourceReport struct {
	// Disable kube-resource-report
	Disabled bool `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	// Specify version to use (see [releases](https://github.com/hjacobs/kube-resource-report/releases))
	Version string `yaml:"version,omitempty" json:"version,omitempty"`
	// update interval in minutes
	UpdateInterval int `yaml:"updateInterval,omitempty" json:"updateInterval,omitempty"`
	// add a fixed extra cost per cluster
	AdditionalClusterCost int32 `yaml:"additionalClusterCost,omitempty" json:"additionalClusterCost,omitempty"`
	// specify costs inline
	Costs map[string]int32 `yaml:"costs,omitempty" json:"costs,omitempty"`
	// specify a CSV file with custom costs for nodes with rows in the form:
	// columns: region,instance-type,monthly-price-usd
	// to apply this add labels to cluster nodes:
	// region is defined via the node label "failure-domain.beta.kubernetes.io/region"
	// instance-type is defined via the node label "beta.kubernetes.io/instance-type"
	CostsFile string `yaml:"costsfile,omitempty" json:"costsFile,omitempty"`
	// a map of extra clusters that kube-resource report will report on.
	// in the form:
	// clusterName: cluster API endpoint
	// e.g.:
	//  extraClusters:
	//    k8s-reports2: "https://10.100.2.69:6443"
	// the CA for the current cluster needs to be trusted by
	// the given external cluster.
	ExternalClusters ExternalClusters `yaml:"extraClusters,omitempty" json:"extraClusters,omitempty"`
	// A comma separated list of labels applied to k8s objects
	// to identify team ownership. These are reported on in the *Teams* tab of the report.
	// Multiple labels may be specified.
	// Default value is "team,owner".
	TeamLabels string `yaml:"teamlabels,omitempty" json:"teamLabels,omitempty"`
}

type MonitoringE2E struct {
	// MinAlertLevel is the minimum alert level for which E2E tests should fail. can be
	// can be one of critical, warning, info
	MinAlertLevel string `yaml:"minAlertLevel,omitempty" json:"minAlertLevel,omitempty"`
}

type Prometheus struct {
	Version     string      `yaml:"version,omitempty" json:"version,omitempty"`
	Disabled    bool        `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Persistence Persistence `yaml:"persistence,omitempty" json:"persistence,omitempty"`
}

type AlertManager struct {
	Version          string   `yaml:"version,omitempty" json:"version,omitempty"`
	Disabled         bool     `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	ConfigNamespaces []string `yaml:"configNamespaces" json:"configNamespaces"`
	OpsgenieAPIKey   string   `yaml:"opsgenieApiKey" json:"opsgenieApiKey"`
}

type Persistence struct {
	// Enable persistence for Prometheus
	Enabled bool `yaml:"enabled" json:"enabled"`
	// Storage class to use. If not set default one will be used
	StorageClass string `yaml:"storageClass,omitempty" json:"storageClass,omitempty"`
	// Capacity. Required if persistence is enabled
	Capacity string `yaml:"capacity,omitempty" json:"capacity,omitempty"`
}

type Memory struct {
	Requests string `yaml:"requests,omitempty" json:"requests,omitempty"`
	Limits   string `yaml:"limits,omitempty" json:"limits,omitempty"`
}

type Grafana struct {
	Version  string `yaml:"version,omitempty" json:"version,omitempty"`
	Disabled bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
}

type Brand struct {
	Name string `yaml:"name,omitempty" json:"name,omitempty"`
	URL  string `yaml:"url,omitempty" json:"url,omitempty"`
	Logo string `yaml:"logo,omitempty" json:"logo,omitempty"`
}

type Kiosk struct {
	Disabled `yaml:",inline" json:",inline"`
}

type GitOperator struct {
	Disabled `yaml:",inline" json:",inline"`
}

type TemplateOperator struct {
	Disabled   `yaml:",inline" json:",inline"`
	SyncPeriod string `yaml:"syncPeriod,omitempty" json:"syncPeriod,omitempty"`
}

type GitOps struct {
	// The name of the gitops deployment, defaults to namespace name
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// Do not scan container image registries to fill in the registry cache, implies `--git-read-only` (default: true)
	DisableScanning *bool `yaml:"disableScanning,omitempty" json:"disableScanning,omitempty"`

	// The namespace to deploy the GitOps operator into, if empty then it will be deployed cluster-wide into kube-system
	Namespace string `yaml:"namespace,omitempty" json:"namespace,omitempty"`

	// The URL to git repository to clone
	GitURL string `yaml:"gitUrl" json:"gitUrl,omitempty"`

	// The git branch to use (default: `master`)
	GitBranch string `yaml:"gitBranch,omitempty" json:"gitBranch,omitempty"`

	// The path with in the git repository to look for YAML in (default: `.`)
	GitPath string `yaml:"gitPath,omitempty" json:"gitPath,omitempty"`

	// The frequency with which to fetch the git repository (default: `5m0s`)
	GitPollInterval string `yaml:"gitPollInterval,omitempty" json:"gitPollInterval,omitempty"`

	// The frequency with which to sync the manifests in the repository to the cluster (default: `5m0s`)
	SyncInterval string `yaml:"syncInterval,omitempty" json:"syncInterval,omitempty"`

	// The Kubernetes secret to use for cloning, if it does not exist it will be generated (default: `flux-$name-git-deploy`)
	GitKey string `yaml:"gitKey,omitempty" json:"gitKey,omitempty"`

	// The contents of the known_hosts file to mount into Flux and helm-operator
	KnownHosts string `yaml:"knownHosts,omitempty" json:"knownHosts,omitempty"`

	// The contents of the ~/.ssh/config file to mount into Flux and helm-operator
	SSHConfig string `yaml:"sshConfig,omitempty" json:"sshConfig,omitempty"`

	// The version to use for flux (default: 1.20.0 )
	FluxVersion string `yaml:"fluxVersion,omitempty" json:"fluxVersion,omitempty"`

	// The version to use for helm operator (default: 1.20.0 )
	HelmOperatorVersion string `yaml:"helmOperatorVersion,omitempty" json:"helmOperatorVersion,omitempty"`

	// a map of args to pass to flux without -- prepended. See [fluxd](https://docs.fluxcd.io/en/1.19.0/references/daemon/) for a full list
	Args map[string]string `yaml:"args,omitempty" json:"args,omitempty"`
}

type Versions struct {
	Kubernetes       string            `yaml:"kubernetes,omitempty" json:"kubernetes,omitempty"`
	ContainerRuntime string            `yaml:"containerRuntime,omitempty" json:"containerRuntime,omitempty"`
	Dependencies     map[string]string `yaml:"dependencies,omitempty" json:"dependencies,omitempty"`
}

type Velero struct {
	Disabled `yaml:",inline" json:",inline"`
	Schedule string            `yaml:"schedule,omitempty" json:"schedule,omitempty"`
	Bucket   string            `yaml:"bucket,omitempty" json:"bucket,omitempty"`
	Volumes  bool              `yaml:"volumes" json:"volumes,omitempty"`
	Config   map[string]string `yaml:"config,omitempty" json:"config,omitempty"`
}

type CA struct {
	Cert       string `yaml:"cert,omitempty" json:"cert,omitempty"`
	PrivateKey string `yaml:"privateKey,omitempty" json:"privateKey,omitempty"`
	Password   string `yaml:"password,omitempty" json:"password,omitempty"`
}

type Thanos struct {
	Disabled `yaml:",inline" json:",inline"`
	// Retention of long-term storage, defaults to 180d
	Retention string `yaml:"retention,omitempty" json:"retention,omitempty"`
	// Must be either `client` or `observability`.
	Mode string `yaml:"mode,omitempty" json:"mode,omitempty"`
	// Bucket to store metrics. Must be the same across all environments
	Bucket string `yaml:"bucket,omitempty" json:"bucket,omitempty"`
	// Only for observability mode. List of client sidecars in `<hostname>:<port>`` format
	ClientSidecars []string `yaml:"clientSidecars,omitempty" json:"clientSidecars,omitempty"`
	// Only for observability mode. Disable compactor singleton if there are multiple observability clusters
	EnableCompactor bool      `yaml:"enableCompactor,omitempty" json:"enableCompactor,omitempty"`
	E2E             ThanosE2E `yaml:"e2e,omitempty" json:"e2e,omitempty"`
}

type ThanosE2E struct {
	Server string `yaml:"server,omitempty" json:"server,omitempty"`
}

type Filebeat struct {
	Disabled      `yaml:",inline" json:",inline"`
	Name          string      `yaml:"name" json:"name"`
	Index         string      `yaml:"index" json:"index"`
	Prefix        string      `yaml:"prefix" json:"prefix"`
	Elasticsearch *Connection `yaml:"elasticsearch,omitempty" json:"elasticsearch,omitempty"`
	Logstash      *Connection `yaml:"logstash,omitempty" json:"logstash,omitempty"`
}

type Journalbeat struct {
	Disabled `yaml:",inline" json:",inline"`
	Kibana   *Connection `yaml:"kibana,omitempty" json:"kibana,omitempty"`
}

type Auditbeat struct {
	Disabled `yaml:",inline" json:",inline"`
	Kibana   *Connection `yaml:"kibana,omitempty" json:"kibana,omitempty"`
}

type Packetbeat struct {
	Disabled      `yaml:",inline" json:",inline"`
	Elasticsearch *Connection `yaml:"elasticsearch,omitempty" json:"elasticsearch,omitempty"`
	Kibana        *Connection `yaml:"kibana,omitempty" json:"kibana,omitempty"`
}

type EventRouter struct {
	Disabled       `yaml:",inline" json:",inline"`
	FilebeatPrefix string `yaml:"filebeatPrefix" json:"filebeatPrefix"`
}

type RedisOperator struct {
	Disabled `yaml:",inline" json:",inline"`
}

type RabbitmqOperator struct {
	Disabled `yaml:",inline" json:",inline"`
}

type Consul struct {
	Version        string `yaml:"version" json:"version"`
	Disabled       bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Bucket         string `yaml:"bucket,omitempty" json:"bucket,omitempty"`
	BackupSchedule string `yaml:"backupSchedule,omitempty" json:"backupSchedule,omitempty"`
	BackupImage    string `yaml:"backupImage,omitempty" json:"backupImage,omitempty"`
}

type Vault struct {
	Version string `yaml:"version" json:"version"`
	// A VAULT_TOKEN to use when authenticating with Vault
	Token string `yaml:"token,omitempty" json:"token,omitempty"`
	// A map of PKI secret roles to create/update See [pki](https://www.vaultproject.io/api-docs/secret/pki/#createupdate-role)
	Roles         map[string]Values      `yaml:"roles,omitempty" json:"roles,omitempty"`
	Policies      map[string]VaultPolicy `yaml:"policies,omitempty" json:"policies,omitempty"`
	GroupMappings map[string][]string    `yaml:"groupMappings,omitempty" json:"groupMappings,omitempty"`
	// ExtraConfig is an escape hatch that allows writing to arbitrary vault paths
	ExtraConfig map[string]Values `yaml:"config,omitempty" json:"extraConfig,omitempty"`
	Disabled    bool              `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	AccessKey   string            `yaml:"accessKey,omitempty" json:"accessKey,omitempty"`
	SecretKey   string            `yaml:"secretKey,omitempty" json:"secretKey,omitempty"`
	// The AWS KMS ARN Id to use to unseal vault
	KmsKeyID string `yaml:"kmsKeyId,omitempty" json:"kmsKeyId,omitempty"`
	Region   string `yaml:"region,omitempty" json:"region,omitempty"`
	Consul   Consul `yaml:"consul,omitempty" json:"consul,omitempty"`
}
type VaultPolicy map[string]VaultPolicyPath

type VaultPolicyPath struct {
	Capabilities      []string            `yaml:"capabilities,omitempty" json:"capabilities,omitempty"`
	DeniedParameters  map[string][]string `yaml:"denied_parameters,omitempty" json:"denied_parameters,omitempty"`
	AllowedParameters map[string][]string `yaml:"allowed_parameters,omitempty" json:"allowed_parameters,omitempty"`
}

func (vaultPolicy VaultPolicy) String() string {
	s := ""
	for path, policy := range vaultPolicy {
		s += fmt.Sprintf(`
		path "%s" {
			capabilities = [%s]
			denied_parameters = {
				%s
			}
			allowed_parameters {
				%s
			}
		}

		`, path, getCapabilities(policy.Capabilities),
			getParameters(policy.DeniedParameters),
			getParameters(policy.AllowedParameters))
	}
	return s
}

func getParameters(params map[string][]string) string {
	s := []string{}
	for param, keys := range params {
		s = append(s, fmt.Sprintf(`"%s" = [%s]`, param, strings.Join(wrap("\"", keys...), ",")))
	}
	return strings.Join(s, "\n")
}
func getCapabilities(capabilities []string) string {
	return strings.Join(wrap("\"", capabilities...), ",")
}

func wrap(with string, array ...string) []string {
	out := []string{}
	for _, item := range array {
		out = append(out, with+item+with)
	}
	return out
}

type ECK struct {
	Disabled `yaml:",inline" json:",inline"`
}

type NodeLocalDNS struct {
	Disabled  bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	DNSServer string `yaml:"dnsServer,omitempty" json:"dnsServer,omitempty"`
	LocalDNS  string `yaml:"localDNS,omitempty" json:"localDNS,omitempty"`
	DNSDomain string `yaml:"dnsDomain,omitempty" json:"dnsDomain,omitempty"`
}

type SealedSecrets struct {
	Enabled     `yaml:",inline" json:",inline"`
	Version     string `yaml:"version,omitempty" json:"version,omitempty"`
	Certificate *CA    `yaml:"certificate,omitempty" json:"certificate,omitempty"`
}

type S3UploadCleaner struct {
	Enabled  `yaml:",inline" json:",inline"`
	Version  string `yaml:"version" json:"version"`
	Endpoint string `yaml:"endpoint" json:"endpoint"`
	Bucket   string `yaml:"bucket" json:"bucket"`
	Schedule string `yaml:"schedule" json:"schedule"`
}

type RegistryCredentials struct {
	Disabled              bool                   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Version               string                 `yaml:"version,omitempty" json:"version,omitempty"`
	Namespace             string                 `yaml:"namespace,omitempty" json:"namespace,omitempty"`
	Aws                   RegistryCredentialsECR `yaml:"aws,omitempty" json:"aws,omitempty"`
	DockerPrivateRegistry RegistryCredentialsDPR `yaml:"dockerRegistry,omitempty" json:"dockerRegistry,omitempty"`
	GCR                   RegistryCredentialsGCR `yaml:"gcr,omitempty" json:"gcr,omitempty"`
	ACR                   RegistryCredentialsACR `yaml:"azure,omitempty" json:"acr,omitempty"`
}

type RegistryCredentialsECR struct {
	Enabled      bool   `yaml:"enabled,omitempty" json:"enabled,omitempty"`
	AccessKey    string `yaml:"accessKey,omitempty" json:"accessKey,omitempty"`
	SecretKey    string `yaml:"secretKey,omitempty" json:"secretKey,omitempty"`
	SessionToken string `yaml:"secretToken,omitempty" json:"sessionToken,omitempty"`
	Account      string `yaml:"account,omitempty" json:"account,omitempty"`
	Region       string `yaml:"region,omitempty" json:"region,omitempty"`
	AssumeRole   string `yaml:"assumeRole,omitempty" json:"assumeRole,omitempty"`
}

type RegistryCredentialsDPR struct {
	Enabled  bool   `yaml:"enabled,omitempty" json:"enabled,omitempty"`
	Server   string `yaml:"server,omitempty" json:"server,omitempty"`
	Username string `yaml:"username,omitempty" json:"username,omitempty"`
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
}

type RegistryCredentialsGCR struct {
	Enabled                bool   `yaml:"enabled,omitempty" json:"enabled,omitempty"`
	URL                    string `yaml:"url,omitempty" json:"url,omitempty"`
	ApplicationCredentials string `yaml:"applicationCredentials,omitempty" json:"applicationCredentials,omitempty"`
}

type RegistryCredentialsACR struct {
	Enabled  bool   `yaml:"enabled,omitempty" json:"enabled,omitempty"`
	URL      string `yaml:"string,omitempty" json:"url,omitempty"`
	ClientID string `yaml:"clientId,omitempty" json:"clientID,omitempty"`
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
}

type PlatformOperator struct {
	Disabled                   bool              `yaml:"disabled,omitempty" json:"disabled,omitempty"`
	Version                    string            `yaml:"version" json:"version,omitempty"`
	EnableClusterResourceQuota bool              `yaml:"enableClusterResourceQuota" json:"enableClusterResourceQuota,omitempty"`
	DefaultImagePullSecret     string            `yaml:"defaultImagePullSecret,omitempty" json:"defaultImagePullSecret,omitempty"`
	RegistryWhitelist          []string          `yaml:"registryWhitelist,omitempty" json:"registryWhitelist,omitempty"`
	DefaultRegistry            string            `yaml:"defaultRegistry,omitempty" json:"defaultRegistry,omitempty"`
	WhitelistedPodAnnotations  []string          `yaml:"whitelistedPodAnnotations,omitempty" json:"whitelistedPodAnnotations,omitempty"`
	Args                       map[string]string `yaml:"args,omitempty" json:"args,omitempty"`
}

type Vsphere struct {
	// GOVC_USER
	Username string `yaml:"username,omitempty" json:"username,omitempty"`
	// GOVC_PASS
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
	// GOVC_DATACENTER
	Datacenter string `yaml:"datacenter,omitempty" json:"datacenter,omitempty"`
	// e.g. ds:///vmfs/volumes/vsan:<id>/
	DatastoreURL string `yaml:"datastoreUrl,omitempty" json:"datastoreUrl,omitempty"`
	// GOVC_DATASTORE
	Datastore string `yaml:"datastore,omitempty" json:"datastore,omitempty"`
	// GOVC_NETWORK
	Network string `yaml:"network,omitempty" json:"network,omitempty"`
	// Cluster for VM placement via DRS (GOVC_CLUSTER)
	Cluster string `yaml:"cluster,omitempty" json:"cluster,omitempty"`
	// GOVC_RESOURCE_POOL
	ResourcePool string `yaml:"resourcePool,omitempty" json:"resourcePool,omitempty"`
	//  Inventory folder (GOVC_FOLDER)
	Folder string `yaml:"folder,omitempty" json:"folder,omitempty"`
	// GOVC_FQDN
	Hostname string `yaml:"hostname,omitempty" json:"hostname,omitempty"`
	// Version of the vSphere CSI Driver
	CSIVersion string `yaml:"csiVersion,omitempty" json:"csiVersion,omitempty"`
	// Version of the vSphere External Cloud Provider
	CPIVersion string `yaml:"cpiVersion,omitempty" json:"cpiVersion,omitempty"`
	// Skip verification of server certificate
	SkipVerify bool `yaml:"verify" json:"verify,omitempty"`
}

func (v Vsphere) GetSecret() map[string][]byte {
	return map[string][]byte{
		v.Hostname + ".username": []byte(v.Username),
		v.Hostname + ".password": []byte(v.Password),
	}
}

type Connection struct {
	URL      string `yaml:"url" json:"url"`
	User     string `yaml:"user,omitempty" json:"user,omitempty"`
	Password string `yaml:"password,omitempty" json:"password,omitempty"`
	Port     string `yaml:"port,omitempty" json:"port,omitempty"`
	Scheme   string `yaml:"scheme,omitempty" json:"scheme,omitempty"`
	Verify   string `yaml:"verify,omitempty" json:"verify,omitempty"`
}

// AuditConfig is used to specify the audit policy file.
// If a policy file is specified them cluster auditing is enabled.
// Configure additional `--audit-log-*` flags under kubernetes.apiServerExtraArgs
type AuditConfig struct {
	PolicyFile string `yaml:"policyFile,omitempty" json:"policyFile,omitempty"`
}

// Specifies Cluster Encryption Provider Config,
// primarily by specifying the Encryption Provider Config File supplied to the cluster API Server.
type EncryptionConfig struct {
	EncryptionProviderConfigFile string `yaml:"encryptionProviderConfigFile,omitempty" json:"encryptionProviderConfigFile,omitempty"`
}

type ConfigMapReloader struct {
	Version  string `yaml:"version" json:"version"`
	Disabled bool   `yaml:"disabled,omitempty" json:"disabled,omitempty"`
}

type Elasticsearch struct {
	Version     string       `yaml:"version" json:"version"`
	Mem         *Memory      `yaml:"mem,omitempty" json:"mem,omitempty"`
	Replicas    int          `yaml:"replicas,omitempty" json:"replicas,omitempty"`
	Persistence *Persistence `yaml:"persistence,omitempty" json:"persistence,omitempty"`
	Disabled    bool         `yaml:"disabled,omitempty" json:"disabled,omitempty"`
}

type Tekton struct {
	Disabled         `yaml:",inline" json:",inline"`
	DashboardVersion string            `yaml:"dashboardVersion,omitempty" json:"dashboardVersion,omitempty"`
	EventsVersion    string            `yaml:"eventsVersion,omitempty" json:"eventsVersion,omitempty"`
	Persistence      Persistence       `yaml:"persistence,omitempty" json:"persistence,omitempty"`
	FeatureFlags     map[string]string `yaml:"featureFlags,omitempty" json:"featureFlags,omitempty"`
}

type VPA struct {
	Disabled `yaml:",inline" json:",inline"`
}

type Test struct {
	// A list of tests to exclude from testings
	Exclude []string `yaml:"exclude,omitempty" json:"exclude,omitempty"`
}

func (c Connection) GetURL() string {
	url := c.URL
	if c.Port != "" && !strings.Contains(url, ":") {
		url = url + ":" + c.Port
	}
	if c.Scheme != "" && !strings.Contains(url, "://") {
		url = c.Scheme + "://" + url
	}
	return url
}

func (p PlatformConfig) GetImagePath(image string) string {
	if p.DockerRegistry == "" {
		return image
	}
	return p.DockerRegistry + "/" + image
}

func (p PlatformConfig) GetVMCount() int {
	count := p.Master.Count
	for _, node := range p.Nodes {
		count += node.Count
	}
	return count
}

func (p *PlatformConfig) String() string {
	data, _ := yaml.Marshal(p)
	return string(data)
}

// +kubebuilder:object:generate=false
type Values struct {
	inner map[string]interface{}
}

func (v *Values) Value() map[string]interface{} {
	return v.inner
}

// UnmarshalYAML is used to customize the YAML unmarshalling of Values
func (v *Values) UnmarshalYAML(unmarshal func(interface{}) error) error {
	type rawValues map[string]interface{}
	raw := rawValues{}

	if err := unmarshal(&raw); err != nil {
		return err
	}

	values := Values{inner: raw}
	*v = values
	return nil
}

// UnmarshalYAML is used to customize the JSON unmarshalling of Values
func (v *Values) UnmarshalJSON(unmarshal func(interface{}) error) error {
	type rawValues map[string]interface{}
	raw := rawValues{}

	if err := unmarshal(&raw); err != nil {
		return err
	}

	values := Values{inner: raw}
	*v = values
	return nil
}

// MarshalYAML for Values
func (v *Values) MarshalYAML() (interface{}, error) {
	return yaml.Marshal(v.inner)
}

// MarshalJSON for Values
func (v *Values) MarshalJSON() (interface{}, error) {
	return json.Marshal(v.inner)
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (v *Values) DeepCopyInto(out *Values) {
	*out = *v
	newInner := map[string]interface{}{}
	_ = copier.Copy(newInner, v.inner)
	out.inner = newInner
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Values
func (v *Values) DeepCopy() *Values {
	if v == nil {
		return nil
	}
	out := new(Values)
	v.DeepCopyInto(out)
	return out
}
