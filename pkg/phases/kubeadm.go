package phases

import (
	"strings"
	"time"

	"github.com/pkg/errors"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
	bootstrapapi "k8s.io/cluster-bootstrap/token/api"
	bootstraputil "k8s.io/cluster-bootstrap/token/util"

	"github.com/moshloop/platform-cli/pkg/api"
	"github.com/moshloop/platform-cli/pkg/platform"
)

func NewClusterConfig(cfg *platform.Platform) api.ClusterConfiguration {
	cluster := api.ClusterConfiguration{
		APIVersion:        "kubeadm.k8s.io/v1beta2",
		Kind:              "ClusterConfiguration",
		KubernetesVersion: cfg.Kubernetes.Version,
		CertificatesDir:   "/etc/kubernetes/pki",
		ClusterName:       cfg.Name,
		ImageRepository:   "k8s.gcr.io",
		// Control plane endpoint is load balanced client side using haproxy + consul service discovery
		ControlPlaneEndpoint: "localhost:8443",
	}
	cluster.Networking.DNSDomain = "cluster.local"
	cluster.Networking.ServiceSubnet = cfg.ServiceSubnet
	cluster.Networking.PodSubnet = cfg.PodSubnet
	cluster.DNS.Type = "CoreDNS"
	cluster.Etcd.Local.DataDir = "/var/lib/etcd"
	cluster.APIServer.CertSANs = []string{"localhost", "127.0.0.1", "k8s-api." + cfg.Domain}
	cluster.APIServer.TimeoutForControlPlane = "4m0s"
	cluster.APIServer.ExtraArgs = map[string]string{
		"oidc-issuer-url":     "https://dex." + cfg.Domain,
		"oidc-client-id":      "kubernetes",
		"oidc-ca-file":        "/etc/ssl/certs/openid-ca.pem",
		"oidc-username-claim": "email",
		"oidc-groups-claim":   "groups",
	}
	if strings.HasPrefix(cluster.APIVersion, "1.16") {
		runtimeConfigs := []string{
			"apps/v1beta1=true",
			"apps/v1beta2=true",
			"extensions/v1beta1/daemonsets=true",
			"extensions/v1beta1/deployments=true",
			"extensions/v1beta1/replicasets=true",
			"extensions/v1beta1/networkpolicies=true",
			"extensions/v1beta1/podsecuritypolicies=true",
		}
		cluster.APIServer.ExtraArgs["runtime-config"] = strings.Join(runtimeConfigs, ",")
	}
	return cluster
}

// createBootstrapToken is extracted from https://github.com/kubernetes-sigs/cluster-api-bootstrap-provider-kubeadm/blob/master/controllers/token.go
func createBootstrapToken(client corev1.SecretInterface) (string, error) {
	// createToken attempts to create a token with the given ID.
	token, err := bootstraputil.GenerateBootstrapToken()
	if err != nil {
		return "", errors.Wrap(err, "unable to generate bootstrap token")
	}

	substrs := bootstraputil.BootstrapTokenRegexp.FindStringSubmatch(token)
	if len(substrs) != 3 {
		return "", errors.Errorf("the bootstrap token %q was not of the form %q", token, bootstrapapi.BootstrapTokenPattern)
	}
	tokenID := substrs[1]
	tokenSecret := substrs[2]

	secretName := bootstraputil.BootstrapTokenSecretName(tokenID)
	secretToken := &v1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: metav1.NamespaceSystem,
		},
		Type: bootstrapapi.SecretTypeBootstrapToken,
		Data: map[string][]byte{
			bootstrapapi.BootstrapTokenIDKey:               []byte(tokenID),
			bootstrapapi.BootstrapTokenSecretKey:           []byte(tokenSecret),
			bootstrapapi.BootstrapTokenExpirationKey:       []byte(time.Now().UTC().Add(2 * time.Hour).Format(time.RFC3339)),
			bootstrapapi.BootstrapTokenUsageSigningKey:     []byte("true"),
			bootstrapapi.BootstrapTokenUsageAuthentication: []byte("true"),
			bootstrapapi.BootstrapTokenExtraGroupsKey:      []byte("system:bootstrappers:kubeadm:default-node-token"),
			bootstrapapi.BootstrapTokenDescriptionKey:      []byte("token generated by platform-cli"),
		},
	}

	if _, err = client.Create(secretToken); err != nil {
		return "", err
	}
	return token, nil
}
